---
title: "Synch_Beta_paper"
output: html_document
date: "2024-06-03"
---

Codes to import the key dataset and run analyses


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width = 5)
```

```{r}
theme_set(theme_bw())
```

install some packages
```{r}
install.packages('tidyverse')
library(tidyverse)
library(ggplot2)
install.packages('iCAMP')
library(iCAMP)
install.packages('reshape2')
library(reshape2)
install.packages('gtools')
library(gtools)
library(data.table)
#library(cluster)
library(vegan)
install.packages('ecodist')
library(ecodist)
library(mFD)
install.packages('betapart')
library(betapart)
library(readr)

install.packages('nlstools')
library(nlstools)

library(nlme)



```


install the multimembership pack
```{r}
if(!require(devtools)){
    install.packages("devtools")
    library("devtools")
}

install_github("jvparidon/lmerMultiMember")
```

# load additional package asscoiated with multimember
```{r}
install.packages('lmerTest')
library(lmerTest) ## from Luke et al 2016 - evaluating significance in linear mixed-effects models in R
library(lme4)
install.packages('sjstats')
library(sjstats) #use for r2 functions
install.packages('performance')
library(performance) ## for ICC
install.packages('sjPlot')
library(sjPlot) #for plotting lmer and glmer mods

install.packages('glmmTMB')
library(glmmTMB)
```




# *import some datasets previously created* 

# import the ELE data (from EcolLett paper )
```{r}
#library(readr)
setwd("~/Documents/SynGeo")
ELE_data <- read_csv("ELE_synchrograms.datamat.csv")
```

#import the grouped table with multiple data for each (nested) basin.
here is where the pairwise betadiversity is also stored
```{r}
basins_grp_tbl=
readRDS('basins_grp_table.rds')
```

# import the 'synchrony_spp'dataframe (for each pair of species'population)
```{r}

#synchrony_spp<- read.csv('synchrony_spp.csv')
```


# this is to extract the 3cols from the pairwise BC based on the mean (across time) composition. 
To repeat for each basin.
```{r}
#basins_grp_tbl$mean.composit[[1]]
dist.3col(basins_grp_tbl$pairwise_bray[[1]])
```

# run this for each basin to extract the mean pairwise BC
```{r}

list1=list()

for (bas in 1: nrow(basins_grp_tbl)){
list1[[bas]]=iCAMP::dist.3col(basins_grp_tbl$pairwise_bray[[bas]])
}
      
```

#extract the pairwise BC for each site pairs and basin
```{r}
pairwiseBC=do.call(rbind, list1)
pairwiseBC$site_pair=paste(pairwiseBC$name1, pairwiseBC$name2, sep="_")
```

#add info on spatial BC (taxonomic) in the synchrony_spp long df
```{r}
synchrony_spp$mean_pair_BC=
  pairwiseBC$dis[match(synchrony_spp$sitepairs1, pairwiseBC$site_pair)]
```


# add the mean spatial BC between sites (within basin) based on mean (across time) composition

```{r}
ELE_data$pair_BC=
  synchrony_spp$mean_pair_BC[match(ELE_data$sitepairs1, synchrony_spp$sitepairs1)]
```


# See that mean decay of similarity follows the same patterns of decay in pop synchrony

```{r fig.width=5.5}
ELE_data %>% 
  filter(Ntw_dist<800) %>% 
  ggplot()+ theme_bw()+
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(), axis.title = element_text(size=20))+
  aes(sqrt(Ntw_dist), (1-pair_BC))+geom_smooth(method = 'nls', formula = y ~ a*exp(b *x), se = FALSE, method.args= list(start =c(a=0.1,b=0.1)), col='#464BB4')+
  
  geom_smooth(data=ELE_data , aes(sqrt(Eucl_dist), (1-pair_BC)), col='Goldenrod2', method = 'nls', formula = y ~ a*exp(b *x), se = FALSE, method.args= list(start =c(a=0.1,b=0.1)), linetype='dotdash')+
  geom_smooth(data=ELE_data %>% filter(flow_connect==1), aes(sqrt(Ntw_dist), (1-pair_BC)), col='#CD3F87', method = 'nls', formula = y ~ a*exp(b *x), se = FALSE, method.args= list(start =c(a=0.1,b=0.1)), linetype='dashed')+
  ylab('Similarity [1-BC]')+xlab(~'Distance'(sqrt(km)))+
  
  geom_segment(aes(x=17, xend=20, y=0.6, yend=0.6), col='#CD3F87', linetype='dashed', size=0.6)+
  geom_segment(aes(x=17, xend=20, y=0.57, yend=0.57), col='#464BB4', size=0.6)+
  geom_segment(aes(x=17, xend=20, y=0.54, yend=0.54), col='Goldenrod2', linetype='dotdash', size=0.6)+
  annotate("text", x=24, y=0.6, label="Flow-connected", col="#CD3F87", size=5 )+
  annotate("text", x=24, y=0.57, label="Watercourse", col="#464BB4", size=5 )+
  annotate("text", x=24, y=0.54, label="Euclidean", col="Goldenrod2", size=5 )
```

NOTES for me
...add here the multimemebership models (must run them again...)
.. for the envdist, I must upload the import code of katies T, and Q data (from SynchBeta_clean.rmd)


##################################
#*import mean air T timeseries, from Katies*
```{r}
library(readr)
Sites_tmean_av <- read_csv("KatieClimateData/Sites_tmean_av_new_sites.csv")
```

#are the actual syncgeo sites there?
```{r}
setdiff(TableSites$sYNGEO_ID, Sites_tmean_av$SiteID)
```

# Work on the *mean Air temp data* - select years mathcin the biotic data
```{r}
#make it long
Sites_tmean_av_long=
Sites_tmean_av %>% 
  pivot_longer(-1, names_to = 'year') 

#remove the X in front of year
Sites_tmean_av_long$year=
  str_replace( Sites_tmean_av_long$year, 'X', '')
 
# Join with the tableSites df
Sites_tmean_av_long=
Sites_tmean_av_long %>% 
  left_join(TableSites[,c(1,2,3)], join_by(SiteID == sYNGEO_ID))

#convert year to numeric
Sites_tmean_av_long$year=as.numeric(Sites_tmean_av_long$year)


# Selection of same time windows as for the bio data
Sites_tmean_av_long=
Sites_tmean_av_long %>% 
  mutate(Sel=ifelse(year < begin  | year > end, 'NO', 'Yes'))

Sites_tmean_av_long=
  Sites_tmean_av_long %>% 
  filter(Sel == 'Yes')

```

# Now add the Basin ID to the temp mean df
```{r}
Sites_tmean_av_long$BasinID=
  TableSites$MAIN_BAS[match(Sites_tmean_av_long$SiteID, TableSites$sYNGEO_ID)]
```

# to get the mean airT values...
```{r}
Sites_tmean_av_long %>% 
  group_by(SiteID) %>% 
  summarise (meanT=mean(value))
```


# Nest within Basin to run synchrony across sites within basin 
```{r}
Sites_tmean.nest=
Sites_tmean_av_long %>% 
  group_by(BasinID) %>% nest()

# the process to get site synchrony in env data (here T) - this will become a function below
tmp$data[[1]] %>% 
  select(SiteID, year, value) %>% pivot_wider(values_from = value, names_from = SiteID) %>% 
  select(-year) %>% 
  cor() %>% as.dist() %>% iCAMP::dist.3col()

```

# *Function to get env. data synchrony within basin*
```{r}
env.synch=
  function(df){
    df %>% select(SiteID, year, value) %>% 
      pivot_wider(values_from = value, names_from = SiteID) %>% 
      select(-year) %>% 
      cor(use="pairwise.complete.obs") %>% as.dist() %>% iCAMP::dist.3col()
  }
```

# Run the function. Get pairwise Tmean synchrony across sites, within basin
```{r}
Sites_tmean.nest=
Sites_tmean.nest %>% 
  mutate(tmean.synch= map(data, env.synch))

Sites_tmean.nest$tmean.synch[[1]]
```
# Unlist the nested list, create the T mean synchonry long df
```{r}
Tmean_synch=
rbindlist(Sites_tmean.nest$tmean.synch)

#add site pair info (to match with other synchrony pairwise data)
Tmean_synch$site_pair=
  paste(Tmean_synch$name1, Tmean_synch$name2, sep="_")
```

```{r}
Tmean_synch %>% filter(name2==147)
```



## Add the mean Air T synchrony (MORAN) to the *synchrony_spp data*
```{r}
#add the site pairs in both orders
synchrony_spp$Tmean_synchrony1=
  Tmean_synch$dis[match(synchrony_spp$sitepairs1, Tmean_synch$site_pair)]

synchrony_spp$Tmean_synchrony2=
  Tmean_synch$dis[match(synchrony_spp$sitepairs2, Tmean_synch$site_pair)]

# then combine the site pair orders to make sure each pairs are covered
synchrony_spp$Tmean_synchrony=
ifelse(is.na(synchrony_spp$Tmean_synchrony1), synchrony_spp$Tmean_synchrony2, synchrony_spp$Tmean_synchrony1)

#remove the partial matches
synchrony_spp$Tmean_synchrony1=NULL
synchrony_spp$Tmean_synchrony2=NULL
```

#*Add the flow connected info into the synchrony_spp*
```{r}
synchrony_spp$flow_conn=
  ELE_data$flow_connect[match( synchrony_spp$sitepairs1, ELE_data$sitepairs1)]
```


# Plot decay of Moran Temp
```{r}
synchrony_spp %>% 
  ggplot()+aes(sqrt(dist_ntw) , Tmean_synchrony)+geom_smooth()+
  geom_smooth(data=synchrony_spp, aes(sqrt(Eucl_dist), Tmean_synchrony), col='Goldenrod2' )+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes(sqrt(dist_ntw), Tmean_synchrony), col='#CD3F87') +
  annotate("text", x=5, y=0.7, label="Flow-connected", col="#CD3F87", size=5 )+
  annotate("text", x=5, y=0.75, label="Watercourse", col="#464BB4", size=5 )+
  annotate("text", x=5, y=0.8, label="Euclidean", col="Goldenrod2", size=5 )+
  ylab('Mean air T synchrony')+ xlab('Distance sqrt(km)')



synchrony_spp %>% 
  ggplot()+aes((dist_ntw) , Tmean_synchrony)+geom_smooth()+
  geom_smooth(data=synchrony_spp, aes((Eucl_dist), Tmean_synchrony), col='Goldenrod2' )+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes((dist_ntw), Tmean_synchrony), col='#CD3F87')



synchrony_spp %>% 
  ggplot()+aes(sqrt(dist_ntw) , Tmean_synchrony)+geom_smooth(method='lm')+
  geom_smooth(data=synchrony_spp, aes(sqrt(Eucl_dist), Tmean_synchrony), col='Goldenrod2' ,method='lm')+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes(sqrt(dist_ntw), Tmean_synchrony), col='#CD3F87',method='lm')



```



####################################################
#### Importing the streamflow data from Katie #####

These are available as .RData file
```{r}
 load("~/Documents/SynGeo/Functional/KatieClimateData/flow_min_max_mean_extracted_new_sites_raw_V2.rdata")
```
check match with sites
```{r}
setdiff(TableSites$sYNGEO_ID, qmean$SiteID)
```

# Work on the *mean streamflow data* - select years mathcin the biotic data
```{r}
#make it long
qmean_long=
qmean %>% 
  pivot_longer(-1, names_to = 'year') 

#remove the X in front of year
qmean_long$year=
  str_replace( qmean_long$year, 'X', '')
 
# Join with the tableSites df
qmean_long=
qmean_long %>% 
  left_join(TableSites[,c(1,2,3)], join_by(SiteID == sYNGEO_ID))

#convert year to numeric
qmean_long$year=as.numeric(qmean_long$year)


# Selection of same time windows as for the bio data
qmean_long=
qmean_long %>% 
  mutate(Sel=ifelse(year < begin  | year > end, 'NO', 'Yes'))

qmean_long=
  qmean_long %>% 
  filter(Sel == 'Yes')

```



# Now add the Basin ID to the temp mean df
```{r}
qmean_long$BasinID=
  TableSites$MAIN_BAS[match(qmean_long$SiteID, TableSites$sYNGEO_ID)]
```


# Nest within Basin to run synchrony across sites within basin 
```{r}
qmean_nest=
qmean_long %>% 
  group_by(BasinID) %>% nest()

# the process to get site synchrony in qmean - this will become a function below
tmp$data[[1]] %>% 
  select(SiteID, year, value) %>% pivot_wider(values_from = value, names_from = SiteID) %>% 
  select(-year) %>% 
  cor() %>% as.dist() %>% iCAMP::dist.3col()

```

# *Function to get env. data synchrony within basin*
```{r}
env.synch=
  function(df){
    df %>% select(SiteID, year, value) %>% 
      pivot_wider(values_from = value, names_from = SiteID) %>% 
      select(-year) %>% 
      cor(use="pairwise.complete.obs") %>% as.dist() %>% iCAMP::dist.3col()
  }
```


# Run the function. *Get pairwise qmean synchrony across sites, within basin*
```{r}
qmean_nest=
qmean_nest %>% 
  mutate(qmean.synch= map(data, env.synch))

qmean_nest$qmean.synch[[1]]
```


# Unlist the nested list, create the T mean synchonry long df
```{r}
qmean_synch=
rbindlist(qmean_nest$qmean.synch)

#add site pair info (to match with other synchrony pairwise data)
qmean_synch$site_pair=
  paste(qmean_synch$name1, qmean_synch$name2, sep="_")
```



## Add the mean Q (streamflow) synchrony to the *synchrony_spp data*
```{r}
#add the site pairs in both orders
synchrony_spp$qmean_synchrony1=
  qmean_synch$dis[match(synchrony_spp$sitepairs1, qmean_synch$site_pair)]

synchrony_spp$qmean_synchrony2=
  Tmean_synch$dis[match(synchrony_spp$sitepairs2, qmean_synch$site_pair)]

# then combine the site pair orders to make sure each pairs are covered
synchrony_spp$qmean_synchrony=
ifelse(is.na(synchrony_spp$qmean_synchrony1), synchrony_spp$qmean_synchrony2, synchrony_spp$qmean_synchrony1)

#remove the partial matches
synchrony_spp$qmean_synchrony1=NULL
synchrony_spp$qmean_synchrony2=NULL
```

#compare distribution of streamflow and temperature synchrony values
```{r}
synchrony_spp

hist(synchrony_spp$qmean_synchrony)

hist(synchrony_spp$Tmean_synchrony)
```

# Plot the decay in streamflow synchrony vs distances
```{r}
synchrony_spp %>% 
  ggplot()+aes(sqrt(dist_ntw) , qmean_synchrony)+geom_smooth()+
  geom_smooth(data=synchrony_spp, aes(sqrt(Eucl_dist), qmean_synchrony), col='Goldenrod2' )+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes(sqrt(dist_ntw), qmean_synchrony), col='#CD3F87') +
  annotate("text", x=5, y=0.7, label="Flow-connected", col="#CD3F87", size=5 )+
  annotate("text", x=5, y=0.75, label="Watercourse", col="#464BB4", size=5 )+
  annotate("text", x=5, y=0.8, label="Euclidean", col="Goldenrod2", size=5 )+
  ylab('Mean Q synchrony')+ xlab('Distance sqrt(km)')


synchrony_spp %>% 
  ggplot()+aes(sqrt(dist_ntw) , qmean_synchrony)+geom_smooth(method='lm')+
  geom_smooth(data=synchrony_spp, aes(sqrt(Eucl_dist), qmean_synchrony), col='Goldenrod2', method='lm' )+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes(sqrt(dist_ntw), qmean_synchrony), col='#CD3F87', method='lm') +
  annotate("text", x=5, y=0.7, label="Flow-connected", col="#CD3F87", size=5 )+
  annotate("text", x=5, y=0.75, label="Watercourse", col="#464BB4", size=5 )+
  annotate("text", x=5, y=0.8, label="Euclidean", col="Goldenrod2", size=5 )+
  ylab('Mean Q synchrony')+ xlab('Distance sqrt(km)')


```

# weak relation between synchrony in air T and synchrony in mean Q 
# Q synchrony can take many negative values (not observed in the temp data)

```{r}
plot(synchrony_spp$qmean_synchrony~synchrony_spp$Tmean_synchrony)
abline(a=0, b=1, col='red')
```


# *model with qmean synchrony shows no effect of streamflow on pop synchrony!*
Streamflow not as Moran driver
```{r}
m1=lme(Correlation ~ dist_ntw + mean_pair_BC+ qmean_synchrony, random=~1|as.factor(basin_ID), 
       data=synchrony_spp %>% select(basin_ID,Correlation, dist_ntw, mean_pair_BC, qmean_synchrony) %>% filter(complete.cases(.)))

summary(m1)
```


#### Work on the QMAX data #####

# Work on the *MAX streamflow data* - select years mathcin the biotic data
```{r}
#make it long
qmax_long=
qmax_av %>% 
  pivot_longer(-1, names_to = 'year') 

#remove the X in front of year
qmax_long$year=
  str_replace( qmax_long$year, 'X', '')
 
# Join with the tableSites df
qmax_long=
qmax_long %>% 
  left_join(TableSites[,c(1,2,3)], join_by(SiteID == sYNGEO_ID))

#convert year to numeric
qmax_long$year=as.numeric(qmax_long$year)


# Selection of same time windows as for the bio data
qmax_long=
qmax_long %>% 
  mutate(Sel=ifelse(year < begin  | year > end, 'NO', 'Yes'))

qmax_long=
  qmax_long %>% 
  filter(Sel == 'Yes')

```



# Now add the Basin ID to the temp mean df
```{r}
qmax_long$BasinID=
  TableSites$MAIN_BAS[match(qmax_long$SiteID, TableSites$sYNGEO_ID)]
```


# Nest within Basin to run synchrony across sites within basin 
```{r}
qmax_nest=
qmax_long %>% 
  group_by(BasinID) %>% nest()

```


# Run the function. *Get pairwise qmax synchrony across sites, within basin*
```{r}
qmax_nest=
qmax_nest %>% 
  mutate(qmax.synch= map(data, env.synch))

qmax_nest$qmax.synch[[1]]
```


# Unlist the nested list, create the T mean synchonry long df
```{r}
qmax_synch=
rbindlist(qmax_nest$qmax.synch)

#add site pair info (to match with other synchrony pairwise data)
qmax_synch$site_pair=
  paste(qmax_synch$name1, qmax_synch$name2, sep="_")
```



## Add the mean Q (streamflow) synchrony to the *synchrony_spp data*
```{r}
#add the site pairs in both orders
synchrony_spp$qmax_synchrony1=
  qmax_synch$dis[match(synchrony_spp$sitepairs1, qmax_synch$site_pair)]

synchrony_spp$qmax_synchrony2=
  Tmean_synch$dis[match(synchrony_spp$sitepairs2, qmax_synch$site_pair)]

# then combine the site pair orders to make sure each pairs are covered
synchrony_spp$qmax_synchrony=
ifelse(is.na(synchrony_spp$qmax_synchrony1), synchrony_spp$qmax_synchrony2, synchrony_spp$qmax_synchrony1)

#remove the partial matches
synchrony_spp$qmax_synchrony1=NULL
synchrony_spp$qmax_synchrony2=NULL
```

#compare distribution of streamflow and temperature synchrony values
```{r}
synchrony_spp

hist(synchrony_spp$qmax_synchrony)

hist(synchrony_spp$Tmean_synchrony)
```

```{r}
plot(synchrony_spp$qmean_synchrony~synchrony_spp$qmax_synchrony)
abline(a=0, b=1, col='red')
```

```{r}
synchrony_spp %>% 
  ggplot()+aes(sqrt(dist_ntw) , qmax_synchrony)+geom_smooth()+
  geom_smooth(data=synchrony_spp, aes(sqrt(Eucl_dist), qmax_synchrony), col='Goldenrod2' )+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes(sqrt(dist_ntw), qmean_synchrony), col='#CD3F87') +
  annotate("text", x=5, y=0.7, label="Flow-connected", col="#CD3F87", size=5 )+
  annotate("text", x=5, y=0.75, label="Watercourse", col="#464BB4", size=5 )+
  annotate("text", x=5, y=0.8, label="Euclidean", col="Goldenrod2", size=5 )+
  ylab('Max Q synchrony')+ xlab('Distance sqrt(km)')


synchrony_spp %>% 
  ggplot()+aes(sqrt(dist_ntw) , qmax_synchrony)+geom_smooth(method='lm')+
  geom_smooth(data=synchrony_spp, aes(sqrt(Eucl_dist), qmax_synchrony), col='Goldenrod2', method='lm' )+
  geom_smooth(data=synchrony_spp %>% filter(flow_conn==1), aes(sqrt(dist_ntw), qmean_synchrony), col='#CD3F87', method='lm') +
  annotate("text", x=5, y=0.7, label="Flow-connected", col="#CD3F87", size=5 )+
  annotate("text", x=5, y=0.75, label="Watercourse", col="#464BB4", size=5 )+
  annotate("text", x=5, y=0.8, label="Euclidean", col="Goldenrod2", size=5 )+
  ylab('Max Q synchrony')+ xlab('Distance sqrt(km)')

```



# Again, streamflow Max not seems to influence biotic synchrony
```{r}
m1=lme(Correlation ~ dist_ntw + mean_pair_BC+ qmax_synchrony, random=~1|as.factor(basin_ID), 
       data=synchrony_spp %>% select(basin_ID,Correlation, dist_ntw, mean_pair_BC, qmax_synchrony) %>% filter(complete.cases(.)))

summary(m1)
```


## Env distance 
# can extract *env distance between sites, using strahler and elevation and mean T, and mean Q*

#first get the mean site temperature
```{r}
mean_site_T=
Sites_tmean_av_long %>% 
  group_by(SiteID) %>% 
  summarise (meanT=mean(value))
```

# get the mean discharge for each site 

```{r}
mean_site_Q=
qmean_long %>% 
  group_by(SiteID) %>% 
  summarise(meanQ=mean(value))
```


# then extract the strahler and elevation
```{r}
names(synchrony_spp)
names(TableSites)

envdata=TableSites[,c(23,25)]

rownames(envdata)=TableSites$sYNGEO_ID


# add the mean air T on the env data 
envdata$meanT=mean_site_T$meanT[match(rownames(envdata), mean_site_T$SiteID)]

# add the mean streamflow (Q) on the env data 
envdata$meanQ=mean_site_Q$meanQ[match(rownames(envdata), mean_site_Q$SiteID)]

envdist=dist(envdata)


# transform to three cols
envdist_mat=iCAMP::dist.3col(envdist)

head(envdist_mat)

```

```{r}
envdist_mat$site_pair=paste(envdist_mat$name1, envdist_mat$name2, sep="_")
```


# *scaled version of env.dist matrix*

```{r}
envdist.scale=dist(scale(envdata))
envdist.scale_mat=iCAMP::dist.3col(envdist.scale)

plot(envdist_mat$dis, envdist.scale_mat$dis)

summary(lm(envdist_mat$dis~ envdist.scale_mat$dis))

envdist.scale_mat$site_pair=paste(envdist.scale_mat$name1, envdist.scale_mat$name2, sep="_")
```


########################################
# Now work on the *MultiMembership models*
########################################

```{r}
library(lmerMultiMember)
library(sjPlot) #for plotting lmer and glmer mods
```

I think we need to unload this to make the mmglm work
```{r}
detach("package:lmerTest", unload = TRUE)
```



## running simple GLMM in multi-member context 
# *first update the env.dist (that now include the mean Q of the sites)*
```{r}
synchrony_spp$env.dist<-
  envdist_mat$dis[match(synchrony_spp$sitepairs1, envdist_mat$site_pair)]

synchrony_spp$env.dist2<-
  envdist_mat$dis[match(synchrony_spp$sitepairs2, envdist_mat$site_pair)]

synchrony_spp$env.dist=
  ifelse(is.na(synchrony_spp$env.dist), synchrony_spp$env.dist2, synchrony_spp$env.dist)

sum(is.na(synchrony_spp$env.dist))

synchrony_spp$env.dist2=NULL
```

# add (to test) scaled env dist
```{r}
synchrony_spp$env.dist_scale<-
  envdist.scale_mat$dis[match(synchrony_spp$sitepairs1, envdist.scale_mat$site_pair)]

synchrony_spp$env.dist2.scale<-
  envdist_mat$dis[match(synchrony_spp$sitepairs2, envdist.scale_mat$site_pair)]

synchrony_spp$env.dist_scale=
  ifelse(is.na(synchrony_spp$env.dist_scale), synchrony_spp$env.dist2.scale, synchrony_spp$env.dist_scale)

synchrony_spp$env.dist2.scale=NULL

```



# create df subset for multi-member model
```{r}


synchrony_spp_mmglm=synchrony_spp %>% 
  select(Correlation, sYNGEO_ID1, sYNGEO_ID2, dist_ntw, mean_pair_BC, Tmean_synchrony, basin_ID, sitepairs1, sitepairs2, Species, env.dist, RaupCrick, Pod.repl, Pod.rich, FunPod.rich, FunPod.repl, env.dist_scale, qmean_synchrony) %>% 
  filter(complete.cases(.))


synchrony_spp_mmglm$sqrt.dist_ntw=sqrt(synchrony_spp_mmglm$dist_ntw)
```



# run different Multi member models with all covariates and select best subset
*model with only network distance X betadiversity as most supported*
```{r}
# the weights for basin_ID
Wa <- lmerMultiMember::weights_from_vector(as.character(synchrony_spp_mmglm$basin_ID))

#the weights for pairwise membership of sites
Wx=lmerMultiMember::weights_from_columns(synchrony_spp_mmglm[,c(2,3)])

# runing a model with all covariates (scaled), and checking results
mmglm1=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) + scale(Tmean_synchrony)+ scale(mean_pair_BC)+scale(env.dist_scale) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)


summary(mmglm1)

summary(mmglm1, ddf = "Satterthwaite")
anova(mmglm1, ddf = "Satterthwaite")
r2_nakagawa(mmglm1) 
check_singularity(mmglm1)

# mm model without env dist 
 mmglm2=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) + scale(Tmean_synchrony)+ scale(mean_pair_BC) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
summary(mmglm2, ddf = "Satterthwaite")

AIC(mmglm1, mmglm2)

# mm model with only betadiv and netw dist (better supported)
 mmglm3=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) + scale(mean_pair_BC) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
summary(mmglm3, ddf = "Satterthwaite")

AIC(mmglm1, mmglm2, mmglm3)
 

# mm model with interaction distance*betadiversity (even better)
 mmglm4=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) * scale(mean_pair_BC) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
summary(mmglm4, ddf = "Satterthwaite")

AIC(mmglm1, mmglm2, mmglm3, mmglm4)
car::Anova(mmglm4)
r2_nakagawa(mmglm4) 

# mm model as before but including the Moran T
# model with MORAN
 mmglm4b=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) * scale(mean_pair_BC) + scale(Tmean_synchrony)+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
summary(mmglm4b, ddf = "Satterthwaite")
Anova(mmglm4b)


 r2_nakagawa(mmglm4b) 

 AIC(mmglm1, mmglm2, mmglm3, mmglm4, mmglm4b)
 
## Model with env distance
 mmglm4c=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) * scale(mean_pair_BC) + scale(env.dist_scale)+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

AIC(mmglm4, mmglm4b, mmglm4c)  

# model with only MORAN_T
 mmglm4d=
lmerMultiMember::lmer(Correlation~ scale(Tmean_synchrony)+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
 
summary(mmglm4d) 
car::Anova(mmglm4d)

# model with both moran and evndist
mmglm4e=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) * scale(mean_pair_BC) + scale(env.dist_scale)+scale(env.dist_scale)+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

 car::Anova(mmglm4e)
 AIC(mmglm4e)
 r2_nakagawa(mmglm4e) 
 
```

 #NON SCALED *not used in paper*
# model as before but not scaled and using directly a variable reporting sqrt of distance (useful for plotting later)
```{r}
synchrony_spp_mmglm$sqrt.dist_ntw=sqrt(synchrony_spp_mmglm$dist_ntw)

 mmglm5=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * mean_pair_BC +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5, ddf = "Satterthwaite")
 
# the Marginal effect remain small, with important contribution of the random components
 r2_nakagawa(mmglm5) 
 
 
# add the Tmean|_synchrony (moran) to test 
  mmglm5b=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * mean_pair_BC + Tmean_synchrony+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

  summary(mmglm5b, ddf = "Satterthwaite")
   r2_nakagawa(mmglm5b)  
 anova(mmglm5b)
  
# model with interaction dist*bray-curtis + Moran is better supported   
AIC(mmglm5, mmglm5b)  


# add the env.dist as well - less supported
  mmglm5c=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * mean_pair_BC + Tmean_synchrony+ env.dist+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

AIC(mmglm5, mmglm5b, mmglm5c) 
  
class(mmglm5b)
  
```

#The scaled version of mm model is slighly less supported (?)
```{r}
AIC(mmglm4b, mmglm5b)
```



# the null (random eff only) mm-model
```{r}
 mmglm_null=
lmerMultiMember::lmer(Correlation~ 
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

r2_nakagawa(mmglm_null)  
```

# likelyhood ratio test
```{r}
(AIC(mmglm_null)- AIC(mmglm4))*log2(exp(1))

anova(mmglm_null, mmglm4)
```

# *Significance of each term using car::Anova *
```{r}
install.packages('car')
require(car)


Anova(mmglm4)
Anova(mmglm5b)
```

# plotting the best model (includes network distance and betadiversity), from model mmglm5b 
# ploting the 5ht, 50, and 90th percentile of betadiversity
# *Fig. 2* ##
```{r fig.width=4.5, fig.height=3.5}
sjPlot::plot_model(mmglm5b, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC[0.1900452, 0.5661769, 0.9306729]'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue'),labels=c('5th', '50th', '90th')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')+labs(col='Beta-diversity\npercentile')+
  theme(legend.position =  c(0.84, 0.72))+theme(axis.title = element_text(size=14))


sjPlot::plot_model(mmglm4b, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC[0.1900452, 0.5661769, 0.9306729]'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue'),labels=c('5th', '50th', '90th')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')+labs(col='Beta-diversity\npercentile')+
  theme(legend.position =  c(0.84, 0.72))+theme(axis.title = element_text(size=14))+theme(axis.text=element_text(size=12))

```
# Export Fig2 mmglm
```{r}
pdf('Plot_mmglm.pdf',w=5, h=4 )
sjPlot::plot_model(mmglm4, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC[0.1900452, 0.5661769, 0.9306729]'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue'),labels=c('5th', '50th', '90th')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')+labs(col='Beta-diversity\npercentile')+
  theme(legend.position =  c(0.84, 0.72))+theme(axis.title = element_text(size=14))+theme(axis.text=element_text(size=12))

dev.off()


tiff('Plot_mmglm.tiff',w=800, h=700, res=300 )
sjPlot::plot_model(mmglm4, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC[0.1900452, 0.5661769, 0.9306729]'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue'),labels=c('5th', '50th', '90th')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')+labs(col='Beta-diversity\npercentile')+
  theme(legend.position =  c(0.84, 0.72))+theme(axis.title = element_text(size=10), axis.text = element_text(size=8), legend.text = element_text(size=3),
                                                legend.title = element_text(size=3))

dev.off()


```






```{r}

sjPlot::plot_model(mmglm5b, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')

sjPlot::plot_model(mmglm4b, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')


```






#*RaupCrick*
# Now working on similar models, but using RaupCrick as betadiversity (independent from alpha diversity)

# mmglm with Raup Crick
```{r}

# the weights for basin_ID
Wa <- lmerMultiMember::weights_from_vector(as.character(synchrony_spp_mmglm$basin_ID))

#the weights for pairwise membership of sites
Wx=weights_from_columns(synchrony_spp_mmglm[,c(2,3)])


 mmglm5_RC=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * RaupCrick +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5_RC, ddf = "Satterthwaite")

r2_nakagawa(mmglm5_RC) 
```
# plot the mmglm with the RaupCrick betadiv
```{r}
sjPlot::plot_model(mmglm5_RC, type='pred', terms = c('sqrt.dist_ntw', 'RaupCrick'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ scale_color_manual(values=c('tomato3', 'gold2', 'steelblue')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')
```






#*Podani replacement and richness decomposition*
# mmglm model with *taxonimic replacement beta*
```{r}
 mmglm5_repl=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) * scale(Pod.repl) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5_repl, ddf = "Satterthwaite")
r2_nakagawa(mmglm5_repl) 

 mmglm5b_repl=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * Pod.repl + Tmean_synchrony+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
summary(mmglm5b_repl, ddf = "Satterthwaite")

AIC(mmglm5_repl, mmglm5b_repl)

#model with only replacement
mmglm5c_repl=
lmerMultiMember::lmer(Correlation~  scale(Pod.repl) + 
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5c_repl)

```

# model with podani richness differences (nestedness component)
```{r}
 mmglm5_rich=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) * scale(Pod.rich) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5_rich, ddf = "Satterthwaite")
r2_nakagawa(mmglm5_rich) 

 mmglm5b_rich=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * Pod.rich + Tmean_synchrony+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

AIC( mmglm5_rich,  mmglm5b_rich) 

# model with only richness diff
 mmglm5c_rich=
lmerMultiMember::lmer(Correlation~  scale(Pod.rich) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5c_rich) 

# when including only the betadiv components, richness-diff seems better supported
AIC(mmglm5c_repl, mmglm5c_rich)
  
```

# using the *Replacement component has more support for modelling synchrony (when modelled with watercourse distance)*
```{r}
AIC(mmglm5_repl, mmglm5_rich)

AIC(mmglm5b_repl, mmglm5b_rich, mmglm4)


car::Anova(mmglm5_repl)
car::Anova(mmglm5_rich)

r2_nakagawa(mmglm5_repl)
r2_nakagawa(mmglm5_rich)


```
# Modelling Both replacement and richness diff components
```{r}
 mmglm5_richANDrepl=
lmerMultiMember::lmer(Correlation~ scale(sqrt.dist_ntw) + scale(Pod.rich) +scale(Pod.repl)+
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)

summary(mmglm5_richANDrepl)

AIC(mmglm5_repl, mmglm5_rich, mmglm5_richANDrepl, mmglm4)
```

# Plotting replacement and richness diff models
```{r}
sjPlot::plot_model(mmglm5_repl, type='pred', terms = c('sqrt.dist_ntw'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ ylab('Population synchrony')

sjPlot::plot_model(mmglm5_rich, type='pred', terms = c('sqrt.dist_ntw'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '')+ ylab('Population synchrony')


  
```


# Plot the decay of synchrony with richness-difference and replacement comp. of beta-diversity
# *Fig.S1*

```{r}

synchrony_spp %>% 
  select(Pod.repl, Correlation, Origin) %>% 
  filter(complete.cases(.)) %>% 
    #filter(Origin !='Sweden') %>% 
  ggplot()+aes(Pod.repl , Correlation)+geom_smooth(method='lm', col='grey20')+xlab('Podani_beta')+ylab('Population synchrony')+
  geom_smooth(data=synchrony_spp, aes(Pod.rich, Correlation), method = 'lm', linetype=5, col='grey20')+xlab('Beta-diversity')+
    annotate('text', x=0.6, y=0.12, label='Richness diff.',  size=5)+
    annotate('text', x=0.6, y=0.04, label='Replacement',  size=5)+
  theme(axis.title = element_text(size=14))+coord_cartesian(ylim = c(0, 0.3))+theme(axis.text=element_text(size=12))


```

# export the podani plot *not sure if this is worth showing*
```{r}
pdf('Plot_Podani.pdf',w=5, h=4 )
synchrony_spp %>% 
  select(Pod.repl, Correlation, Origin) %>% 
  filter(complete.cases(.)) %>% 
    #filter(Origin !='Sweden') %>% 
  ggplot()+aes(Pod.repl , Correlation)+geom_smooth(method='lm', col='grey20')+xlab('Podani_beta')+ylab('Population synchrony')+
  geom_smooth(data=synchrony_spp, aes(Pod.rich, Correlation), method = 'lm', linetype=5, col='grey20')+xlab('Beta-diversity')+
    annotate('text', x=0.6, y=0.12, label='Richness diff.',  size=5)+
    annotate('text', x=0.6, y=0.04, label='Replacement',  size=5)+  theme(axis.title = element_text(size=14), axis.text = element_text(size=12))
dev.off()
```



###############

### Add quantiles of betadiv (as done on previous models)
This allows calculating model parameters for low vs high betadiversity groups of pairs
```{r}
library(gtools)

synchrony_spp_mmglm$mean_pair_BC_Q3=
  quantcut(synchrony_spp_mmglm$mean_pair_BC, q=3)

levels(synchrony_spp_mmglm$mean_pair_BC_Q3)
```


# re create the multi-member model, just for the *low betadiv*
*here multi-member interc =0.246*
```{r}


tmp1b=synchrony_spp_mmglm %>% filter(mean_pair_BC_Q3=='[0,0.456]') 

# the weights for basin_ID
Wa <- lmerMultiMember::weights_from_vector(as.character(tmp1b$basin_ID))

#the weights for pairwise membership of sites
Wx=weights_from_columns(tmp1b[,c(2,3)])


test2=
lmerMultiMember::lmer(Correlation~ sqrt(dist_ntw) + 
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=tmp1b)

summary(test2)
  
```


# multi member model for *high betadiv*
# *Multi-member interc =0.135*
```{r}
tmp1b=synchrony_spp_mmglm %>% filter(mean_pair_BC_Q3=="(0.691,0.998]")

# the weights for basin_ID
Wa <- lmerMultiMember::weights_from_vector(as.character(tmp1b$basin_ID))

#the weights for pairwise membership of sites
Wx=weights_from_columns(tmp1b[,c(2,3)])


test2=
lmerMultiMember::lmer(Correlation~ sqrt(dist_ntw) + 
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=tmp1b)

summary(test2)
```


# *difference in intercept (low-high beta) = 0.111*
```{r}
0.246 - 0.135
```





## *Working on setting up null-model to derive expected intercept for low vs high betadiversity*
# Work setup again the permutation of the quantiles
constrained permutation of betadivrsity quantiles WITHIN basins
```{r}
library(permute)
h1_basins_mmglm<-how(within=Within(), blocks=synchrony_spp_mmglm$basin_ID)

shuffle(synchrony_spp_mmglm$mean_pair_BC, control = h1_basins_mmglm)
```


# Function that shuffles beta quantiles within same basin - work on mmglm synchrony dataset
```{r}
#shuffle_beta.fn<-function(x){
#  synchrony_spp_mmglm[shuffle(x, control=h1_basins),]$mean_pair_BC_Q3
#}

shuffle_beta.fn<-function(x){
  x[shuffle(x, control=h1_basins_mmglm),]$mean_pair_BC_Q3
}

shuffle_beta.fn(synchrony_spp_mmglm)
```




# create null model function (for intercept) to work with multi member models
```{r}
extr.null.int_mmglm<- function(xx){
  xx$null.beta<-shuffle_beta.fn(xx) # assign the shuffled values of beta quantiles
  
  #create a tmp data for low betadiv values
datalow=xx %>% filter(null.beta=='[0,0.456]')
  
  # the weights for basin_ID
Wa_low <- lmerMultiMember::weights_from_vector(as.character(datalow$basin_ID))
#the weights for pairwise membership of sites
Wx_low=weights_from_columns(datalow[,c(2,3)])

# the mmglm model for lowbeta
low=lmerMultiMember::lmer(Correlation ~ sqrt(dist_ntw) + (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa_low, Pairs = Wx_low), REML = T, 
            data=datalow )
  
###########
# create a second tmp data for high betadiv values
 datahigh=xx %>% filter(null.beta=="(0.691,0.998]")
  
  # the weights for basin_ID
Wa_high <- lmerMultiMember::weights_from_vector(as.character(datahigh$basin_ID))
#the weights for pairwise membership of sites
Wx_high=weights_from_columns(datahigh[,c(2,3)])

# the mmglm model for lowbeta
high=lmerMultiMember::lmer(Correlation ~ sqrt(dist_ntw) + (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa_high, Pairs = Wx_high), REML = T, 
            data=datahigh )

    
  final=  cbind.data.frame(lowBeta=low@beta[1], highBeta=high@beta[1])
  
  return(final)
}
```



#test function
```{r}
extr.null.int_mmglm(synchrony_spp_mmglm)

```

```{r}
tmp_null=replicate(20, extr.null.int_mmglm(synchrony_spp_mmglm))
old.null.inter_BC_mmglm=null.inter_BC_mmglm
```



# Run the null model n times (to be increased)
```{r}
null.inter_BC_mmglm=replicate(500, extr.null.int_mmglm(synchrony_spp_mmglm))

null.inter_BC_mmglm.df=data.frame(matrix(ncol=2, nrow = 500))
for(i in 1:500) null.inter_BC_mmglm.df[i,]=null.inter_BC_mmglm[,,i]

names(null.inter_BC_mmglm.df)=c('lowBeta', 'highBeta')

null.inter_BC_mmglm.df$diff_intercept=null.inter_BC_mmglm.df$lowBeta - null.inter_BC_mmglm.df$highBeta
colMeans(null.inter_BC_mmglm.df)

```


*observed diff in intercept = 0.111*

# z-score of differences between intercept of synchrony decay for low vs high betadiversity
```{r}
(0.111 - mean(null.inter_BC_mmglm.df$diff_intercept)) /
  sd(null.inter_BC_mmglm.df$diff_intercept)
```

# z-score for high betadiversity intercept
```{r}
(0.135 - mean(null.inter_BC_mmglm.df$highBeta)) /
  sd (null.inter_BC_mmglm.df$highBeta)
```

# z-score for low betadiversity intercept
```{r}
(0.246 - mean(null.inter_BC_mmglm.df$lowBeta))/
  sd(null.inter_BC_mmglm.df$lowBeta)
```



# Plotting the mmglm based intercept from observed and null betadiv values
```{r}
lowbeta.plot_mmglm=
null.inter_BC_mmglm.df %>% 
  ggplot()+aes(y=lowBeta)+geom_density(fill='grey')+geom_segment(aes(x=0, y=0.246, xend=40, yend=0.246), col='tomato2', linewidth=1)+
  #ylab('Low betadiversity - Model intercept')+
  xlab(NULL)+ylab(NULL)+theme(axis.text.y = element_text(size=10), axis.text.x = element_blank())+
  annotate('text', x=12, y = 0.21, label ='Null intercept', size=5)+
  annotate('text', x=14, y =0.25, label = 'Observed intercept', size=4)


highbeta.plot_mmglm=
null.inter_BC_mmglm.df %>% 
  ggplot()+aes(y=highBeta)+geom_density(fill='grey')+geom_segment(aes(x=0, y=0.135, xend=40, yend=0.135), col='steelblue', linewidth=1)+
  xlab(NULL)+ylab(NULL)+theme(axis.text.y = element_text(size=10), axis.text.x = element_blank())+
  annotate('text', x=15, y = 0.175, label ='Null intercept', size=5)+
  annotate('text', x=16, y =0.145, label = 'Observed intercept', size=4)

```



# plotting the mmglm model with BC quantiles (as in null approach)
```{r}

# the weights for basin_ID
Wa <- lmerMultiMember::weights_from_vector(as.character(synchrony_spp_mmglm$basin_ID))

#the weights for pairwise membership of sites
Wx=weights_from_columns(synchrony_spp_mmglm[,c(2,3)])


 mmglm_qbc=
lmerMultiMember::lmer(Correlation~ sqrt.dist_ntw * (mean_pair_BC_Q3) +
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=synchrony_spp_mmglm)
summary(mmglm_qbc, ddf = "Satterthwaite")


plot_mmglm_BC_q=
sjPlot::plot_model(mmglm_qbc, type='pred', terms = c('sqrt.dist_ntw', 'mean_pair_BC_Q3'), axis.title = c('Watercourse distance (sqrt)','Population synchrony' ), title = '') + scale_color_manual(values=c('tomato3', 'gold2', 'steelblue')) +scale_fill_manual(values=c('tomato3', 'gold2', 'steelblue'))+ylab('Population synchrony')+ labs(color='Bray-Curtis_Q')
```


# Model the null distribution and the observed intercept (from the models based on just the low  and high betadiversity)
Also plot along the overall multimembership model with the three-factor quantiles of betadiversity as reference
```{r fig.width=7.5}
#install.packages('patchwork')
library(patchwork)

plot( (lowbeta.plot_mmglm / highbeta.plot_mmglm) | plot_mmglm_BC_q, ncol=2)+plot_annotation(tag_levels = 'A')
```



```{r}

plot_null_low=
null.inter_BC_mmglm.df %>% 
  ggplot()+aes(y=lowBeta, ..scaled..)+geom_density(fill='grey')+geom_segment(aes(x=0, y=0.245, xend=1, yend=0.245), col='tomato2', linewidth=0.6)+
  xlab(NULL)+ylab(NULL)+theme_classic()+
  ylim(c(0.13, 0.255))+
  #annotate('text', x=12, y = 0.21, label ='Null distribution', size=5)+
  annotate('text', x=0.4, y =0.252, label = 'Observed - low beta-diversity', size=4)+
  theme(axis.title.y = element_text(size=15), axis.text.x = element_blank())


plot_null_high=
null.inter_BC_mmglm.df %>% 
  ggplot()+aes(y=highBeta,..scaled..)+geom_density(fill='grey')+geom_segment(aes(x=0, y=0.135, xend=1, yend=0.135), col='steelblue', linewidth=0.6)+
  xlab(NULL)+ylab(NULL)+theme_classic()+
  ylim(c(0.13, 0.255))+
  #annotate('text', x=0.5, y = 0.175, label ='Null distribution', size=5)+
  annotate('text', x=0.4, y =0.145, label = 'Observed - high beta-diversity', size=4)+ylab('Null & observed intercept')+
  theme(axis.title.y = element_text(size=13), axis.title.x = element_text(size=13))+xlab('Scaled density')
```

# *Fig 4 - Null intercepts*
```{r fig.width=4, fig.height=3.5}
plot_null_low / plot_null_high +
  plot_layout(axis_titles = "collect")

```
# Export the null model distribution
```{r}
pdf('null.model.plots.pdf', w=4, h=4)
plot_null_low / plot_null_high +
  plot_layout(axis_titles = "collect")
dev.off()

```




##################
# work on the SEM 
##################

Synch beta clean script has entire SEM stuff



```{r}
install.packages('piecewiseSEM')
library(piecewiseSEM)
library(nlme)
```

```{r}

synchrony_spp_mmglm$synchrony=synchrony_spp_mmglm$Correlation
synchrony_spp_mmglm$Moran_T=synchrony_spp_mmglm$Tmean_synchrony

#names(synchrony_spp_mmglm)[1]='synchrony'
#names(synchrony_spp_mmglm)[6]='Moran_T'
#rename this variable to follow SEM script from other (previous) session
synchrony_spp_mmglm$env_dis=synchrony_spp_mmglm$env.dist
```


## Run the piecewiseSEM with the env distance as additional exogenous var and the betadiv as direct effect on synchrony
```{r}
psem1<-
  psem(
    lme(synchrony~ dist_ntw + Moran_T+ mean_pair_BC, random=~1|basin_ID, data=synchrony_spp_mmglm),
    lme(mean_pair_BC ~ dist_ntw + env_dis, random=~1|basin_ID, data=synchrony_spp_mmglm),
    data=synchrony_spp_mmglm
    
  )
```



# look at direct separation test. *betadiversity linked to Moran!*
```{r}
basisSet(psem1)
dSep(psem1)
```
#Update SEM to include betadiversity influenced by Moran
```{r}
psem2<-
  update(psem1,
      mean_pair_BC ~ dist_ntw + env_dis+Moran_T
  )
```

```{r}
dSep(psem2)

coefs(psem2)
rsquared(psem2)

plot(psem2)
```


# inclusion of link between betadiversity and Moran is justified
```{r}
AIC(psem1, psem2)
```

# must include a random effect for species as well
```{r}

psem_spp<-
  psem(
    lme(synchrony~ (dist_ntw) + Moran_T+ mean_pair_BC, random=list(basin_ID=~1, Species=~1), data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    lme(mean_pair_BC ~ (dist_ntw) + env.dist+ Moran_T, random=~1|basin_ID, data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    data=synchrony_spp_mmglm)

# including square root transformation of distance (as in Ecology Letter models)
psem_spp3<-
  psem(
    lme(synchrony~ sqrt(dist_ntw) + Moran_T+ mean_pair_BC, random=list(basin_ID=~1, Species=~1), data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    lme(mean_pair_BC ~ sqrt(dist_ntw) + env.dist+ Moran_T, random=~1|basin_ID, data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    data=synchrony_spp_mmglm)

# without the effect of env dist on betadiv
psem_spp3_b<-
  psem(
    lme(synchrony~ sqrt(dist_ntw) + Moran_T+ mean_pair_BC, random=list(basin_ID=~1, Species=~1), data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    lme(mean_pair_BC ~ sqrt(dist_ntw)+ Moran_T , random=~1|basin_ID, data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    data=synchrony_spp_mmglm)


dSep(psem_spp3_b)

```

```{r}
AIC(psem_spp, psem_spp3, psem_spp3_b)
```

# Psem_spp3 seems better supported than psem_spp1, for the inlcusion of sqrt(dist_ntw), and the *global fisher test is NON sig. as it should *
```{r}
summary(psem_spp3)
summary(psem_spp3)$coeff

dSep(psem_spp3)
```

# Plotting the most supported SEM
```{r}
plot(psem_spp3, node_attrs = list(size=2))
```


```{r}
#indirect eff of betadiv via distace
0.212*-0.077

```






# Plot residual synchrony vs betadiv for psem_spp3
```{r}
resid_psem3.spp=
partialResid(synchrony ~ mean_pair_BC, psem_spp3)
```

# *Fig 4 residual*
```{r fig.width=5, fig.height=4}
pdf('plot.resid.pdf', w=5, h=4)
resid_psem3.spp %>% 
ggplot()+aes(xresid, yresid)+geom_smooth(col='black', size=2)+xlab('Residual beta-diversity')+ylab('Residual synchrony')+theme_classic()+
  theme(axis.title = element_text(size=22), axis.text = element_text(size=14))
dev.off()
```


# *Update psem_spp3 to include correlation between Moran and spatial distance*
```{r}
cerror(Moran_T %~~% dist_ntw, psem_spp3, synchrony_spp_mmglm)
```

# psem with correlation between external variables
```{r}
psem_spp3.update<-
  update(psem_spp3, Moran_T %~~% dist_ntw)
```

```{r}
summary(psem_spp3.update)
plot(psem_spp3.update)
```


# Eventually update sem to include correlation and env.distance as scaled.

# *Psem_spp3_scale (with scaled env distances)*
```{r}
psem_spp3.scale<-
  psem(
    lme(synchrony~ sqrt(dist_ntw) + Moran_T+ mean_pair_BC, random=list(basin_ID=~1, Species=~1), data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    lme(mean_pair_BC ~ sqrt(dist_ntw) + env.dist_scale+ Moran_T, random=~1|basin_ID, data=synchrony_spp_mmglm, control=lmeControl(opt = "optim")),
    data=synchrony_spp_mmglm)


```

```{r}
summary(psem_spp3.scale)
```

# *psem scaled env.dist with correlation between ntw_dist ~ Moran*
```{r}
psem_spp3.scale.update<-
  update(psem_spp3.scale, Moran_T %~~% dist_ntw)

summary(psem_spp3.scale.update)

plot(psem_spp3.scale.update)

dSep(psem_spp3.scale.update)
```
# inclusion of random error does not affect the fixed effects
```{r}
AIC(psem_spp3.scale, psem_spp3.scale.update)
```



## *also include corr error between spatial dist ~ env dist*

```{r}
cerror(env.dist_scale %~~% dist_ntw, psem_spp3.scale.update, synchrony_spp_mmglm)


```

# *Final PSEM with correlated errors (netw_dist~~Moran + ntew_dist~~env.dist)*
```{r}
psem_spp3.scale.update2<-
  update(psem_spp3.scale.update, env.dist_scale %~~% dist_ntw)
```

```{r}
summary(psem_spp3.scale.update2)
plot(psem_spp3.scale.update2)
```



# Plot residual synchrony vs betadiv for psem_spp3.scale.update2
```{r}
resid_psem_spp3.scale.update2=
partialResid(synchrony ~ mean_pair_BC, psem_spp3.scale.update2)
```

# *Fig 4 residual*
```{r fig.width=4, fig.height=4}
pdf('plot.resid.pdf', w=5, h=4)

resid_psem_spp3.scale.update2 %>% 
ggplot()+aes(xresid, yresid)+geom_smooth(col='black', size=2)+xlab('Residual beta-diversity')+ylab('Residual synchrony')+theme_classic()+
  theme(axis.title = element_text(size=22), axis.text = element_text(size=14))
dev.off()

```



# As SEM do not support multimbmbership random model, we test the individual paths separately in multi-member framwork.

```{r}
# create temporary data
tmp1=synchrony_spp %>% 
  select(Correlation, sYNGEO_ID1, sYNGEO_ID2, dist_ntw, mean_pair_BC, Tmean_synchrony, basin_ID, sitepairs1, sitepairs2, Species, env.dist) %>% 
  filter(complete.cases(.))

# the weights for basin_ID
Wa <- lmerMultiMember::weights_from_vector(as.character(tmp1$basin_ID))

#the weights for pairwise membership of sites
Wx=weights_from_columns(tmp1[,c(2,3)])

# no interaction needed here, as pairwise site are not nested or appearing in more than one basin
#Wax=interaction_weights(Wa, Wx)

```

# test the multimember models, here using the same model structure as in the SEM

Must deload the lmerTest. This issue need checking
```{r}

detach("package:lmerTest", unload = TRUE)
detach("package:lmerMultiMember", unload = TRUE)
library(lmerTest)
library(lmerMultiMember)

```


```{r}

test1= lmerMultiMember::lmer(Correlation~ sqrt(dist_ntw) + Tmean_synchrony+ mean_pair_BC+ 
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=tmp1)


test2= lmerMultiMember::lmer(mean_pair_BC~ sqrt(dist_ntw) + Tmean_synchrony+ env.dist+ 
              (1 | basin_ID) + (1|Species) + (1 | Pairs),
            memberships = list(basin_ID = Wa, Pairs = Wx), REML = T, data=tmp1)


summary(test1, ddf = "Satterthwaite")
r2_nakagawa(test1)
summary(test2)
```
```{r}
class(test1)<-"lmerModLmerTest"
```

```{r}
plot(test1)
```


```{r}
plot(wangs_basins$CV_C_R ~ wangs_basins$mean_bray)
plot(wangs_basins$CV_S_L ~ wangs_basins$mean_bray)
plot(wangs_basins$CV_C_L ~ wangs_basins$mean_bray)
plot(wangs_basins$CV_S_R ~ wangs_basins$mean_bray)

plot(wangs_basins$CV_C_R ~ wangs_basins$resdi_Ed.Wd.ratio)
plot(wangs_basins$CV_C_R ~ wangs_basins$gamma.shannon)
plot(wangs_basins$phi_S2C_R ~ wangs_basins$gamma.shannon)
plot(wangs_basins$phi_S2C_R ~ wangs_basins$mean_bray)
plot(wangs_basins$phi_S2C_L ~ wangs_basins$mean_bray)
plot(wangs_basins$phi_S_L2R~ wangs_basins$mean_bray)
plot(wangs_basins$phi_C_L2R ~ wangs_basins$mean_bray)
plot(wangs_basins$phi_C_L2R ~ wangs_basins$gamma.rich)
```


```{r}
names(basins_grp_tbl)


```

```{r}
tmp=
  basins_grp_tbl %>% 
  select(basinID, mean.bray)

tmp$mean.bray_unlist=
  unlist(tmp$mean.bray)

tmp$mean.bray=NULL

write.csv(tmp, file='basin_mean_bray.csv')
```



```{r}
tmp=
synchrony_spp %>% filter(is.na(mean_pair_BC))
```

site with no bray-curtis values(1spp only)
```{r}
sites_excluded=
unique(tmp$sYNGEO_ID2)
```


```{r}
id1=unique(synchrony_spp$sYNGEO_ID1)
id2=unique(synchrony_spp$sYNGEO_ID2)

```

```{r}
sort(id1)
sort(id2)
```


```{r}
setdiff(id1,id2) # only in id1
setdiff(id2,id1) # only in id2



setdiff(TableSites$sYNGEO_ID, unique(synchrony_spp$sYNGEO_ID2)) 
setdiff(TableSites$sYNGEO_ID, unique(synchrony_spp$sYNGEO_ID1)) 


```

```{r}
#sites in common id1 and id2 of the pairs
common_id1_id2=
id1[id1%in%id2]

length(common_id1_id2) # 1046

# total sites
total_sites=c(common_id1_id2, setdiff(id1,id2), setdiff(id2,id1))
length(total_sites) # 1191. Need to exclude those with only 1 spp (no betadiv)


setdiff(TableSites$sYNGEO_ID, total_sites)

```


